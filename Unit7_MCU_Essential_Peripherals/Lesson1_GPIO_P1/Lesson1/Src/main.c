/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdlib.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//RCC
#define  RCC_BASE   				( uint32_t )( 0x40021000 )
#define  RCC_CR     				*( volatile uint32_t *)( RCC_BASE + 0x0 )
#define  RCC_CFGR   				*( volatile uint32_t *)( RCC_BASE + 0x04 )
#define RCC_APB2ENR                 *( ( volatile uint32_t* )( RCC_BASE + 0x18 ) )

//GPIOA
#define GPIOA_BASE                  ( uint32_t )0x40010800
#define GPIOA_CRH                   *( ( volatile uint32_t* )( GPIOA_BASE + 0x04 ) )
#define GPIOA_CRL					*( volatile uint32_t * )( GPIOA_BASE + 0x00 )
#define GPIOA_ODR                   *( ( volatile uint32_t* )( GPIOA_BASE + 0x0C ) )
#define GPIOA_IDR                   *( ( volatile uint32_t* )( GPIOA_BASE + 0x08 ) )

//GPIOB
#define GPIOB_BASE                  ( uint32_t )0x40010C00
#define GPIOB_CRH                   *( ( volatile uint32_t* )( GPIOB_BASE + 0x04 ) )
#define GPIOB_CRL					*( volatile uint32_t * )( GPIOB_BASE + 0x00 )
#define GPIOB_ODR                   *( ( volatile uint32_t* )( GPIOB_BASE + 0x0C ) )
#define GPIOB_IDR                   *( ( volatile uint32_t* )( GPIOA_BASE + 0x08 ) )

//EXTI
#define EXTI_BASE	        		( uint32_t )0x40010400
#define EXTI_RTSR					*( volatile uint32_t* )( EXTI_BASE + 0x08 )
#define EXTI_IMR					*( volatile uint32_t* )( EXTI_BASE + 0x00 )
#define EXTI_PR		    			*( volatile uint32_t* )( EXTI_BASE + 0x14 )

//AFIO
#define AFIO_BASE	        		( uint32_t )0x40010000
#define AFIO_EXTICR1    			*( volatile uint32_t* )( AFIO_BASE + 0x08 )

//NVIC
#define NVIC_ISER0					*( volatile uint32_t* )( 0xE000E100 )

#define RCC_IOPAEN                  ( 1 << 2 )
#define RCC_IOPBEN                  ( 1 << 3 )

#define GPIOA_1                     ( 1 << 1 )
#define GPIOA_13                    ( 1 << 13 )

#define GPIOB_1                     ( 1 << 1 )
#define GPIOB_13                    ( 1 << 13 )

void Wait(unsigned int x)
{
	int i,j;

	for(i = 0 ; i < x ; i++)
		for(j = 0 ; j < 255 ; j++);
}

void Clock_Init()
{
	// enable PORTA ,PORTB clock
	RCC_APB2ENR |= RCC_IOPAEN | RCC_IOPBEN;
}


void GPIO_Init()
{
	//PIN A1 as floating input (reset state)
	GPIOA_CRL |= ( 1 << 6 );

	//PIN A13 as floating input (reset state)
	GPIOA_CRH |= ( 1 << 20 );

	//PIN B1 as General purpose output push-pull,max speed 10 MHz.
	GPIOB_CRL &= ~( 7 << 4 );
	GPIOB_CRL |= ( 2 << 4 );

	//PIN B13 as General purpose output push-pull,max speed 10 MHz.
	GPIOB_CRH &= ~( 7 << 20 );
	GPIOB_CRH |= ( 2 << 20 );
}

int main(void)
{
	Clock_Init();
	GPIO_Init();

	while(1)
	{
		if( (GPIOA_IDR & GPIOA_1) == 0 )  //Press
		{
			GPIOB_ODR ^= (GPIOB_1);

			while( (GPIOA_IDR & GPIOA_1) == 0 );  //Single press
		}

		if( (GPIOA_IDR & GPIOA_13) != 0 )  //Press
		{
			GPIOB_ODR ^= (GPIOB_13);
		}

		Wait(1);
	}
}

